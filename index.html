<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>My Enhanced Splash Page</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, 
                 Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    color: #fff;
    overflow-x: hidden;
    background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
    position: relative;
  }

  #canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
  }

  .hero {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    z-index: 10;
  }

  h1 {
    font-size: 4rem;
    margin: 0;
    letter-spacing: 0.05em;
    opacity: 0;
    animation: fadeSlide 1.5s forwards;
  }

  h2 {
    font-size: 1.2rem;
    font-weight: 300;
    margin-top: 1rem;
    margin-bottom: 3rem;
    opacity: 0;
    animation: fadeSlide 1.5s 0.5s forwards;
  }

  @keyframes fadeSlide {
    0% {
      opacity: 0;
      transform: translateY(30px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .links {
    display: flex;
    flex-wrap: wrap;
    gap: 2rem;
    justify-content: center;
    opacity: 0;
    animation: fadeSlide 1.5s 1s forwards;
  }

  .links a {
    color: #fff;
    text-decoration: none;
    font-size: 1rem;
    font-weight: 400;
    letter-spacing: 0.05em;
    border-bottom: 1px solid transparent;
    transition: all 0.3s ease;
  }

  .links a:hover {
    border-bottom: 1px solid #fff;
  }

  .content, .bottom-section {
    position: relative;
    z-index: 10;
    padding: 100px 20px;
    max-width: 600px;
    margin: 0 auto;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 10px;
    backdrop-filter: blur(5px);
  }

  .bottom-section {
    margin-bottom: 200px;
  }
</style>
</head>
<body>
<div id="canvas-container"></div>

<div class="hero">
  <h1>Hello, I'm Kyzer</h1>
  <h2>Exploring ideas and crafting experiences</h2>
  <div class="links">
    <a href="https://github.com/derkyzer" target="_blank" rel="noopener noreferrer">
      My GitHub
    </a>
    <a href="./snake.html">Play Snake</a>
    <a href="./projects.html">Projects</a>
    <a href="./o1.html">Home vo1</a>
  </div>
</div>

<div class="content">
  <h3>About My Work</h3>
  <p>
    As you scroll through this page, watch how the Tetris pieces respond to your movement.
    Each piece is a physical object that reacts to scrolling forces and collisions.
  </p>
</div>

<div class="bottom-section">
  <h3>More Content Below</h3>
  <p>
    The physics-based background creates an engaging and interactive experience
    as you navigate through the content.
  </p>
</div>

<script>
// Matter.js module aliases
const { Engine, Render, World, Bodies, Body, Composite, Common } = Matter;

// Create engine and world
const engine = Engine.create();
const world = engine.world;

// Create renderer
const canvas = document.createElement('canvas');
const container = document.getElementById('canvas-container');
container.appendChild(canvas);
const render = Render.create({
    canvas: canvas,
    engine: engine,
    options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: 'transparent'
    }
});

// Tetris pieces definitions
const tetrisPieces = [
    // I piece
    {
        blocks: [[0,0], [0,1], [0,2], [0,3]],
        color: '#00f0f0'
    },
    // O piece
    {
        blocks: [[0,0], [1,0], [0,1], [1,1]],
        color: '#f0f000'
    },
    // T piece
    {
        blocks: [[0,0], [1,0], [2,0], [1,1]],
        color: '#a000f0'
    },
    // L piece
    {
        blocks: [[0,0], [0,1], [0,2], [1,2]],
        color: '#f0a000'
    },
    // J piece
    {
        blocks: [[1,0], [1,1], [1,2], [0,2]],
        color: '#0000f0'
    },
    // S piece
    {
        blocks: [[1,0], [2,0], [0,1], [1,1]],
        color: '#00f000'
    },
    // Z piece
    {
        blocks: [[0,0], [1,0], [1,1], [2,1]],
        color: '#f00000'
    }
];

// Create walls
const wallThickness = 60;
const walls = [
    Bodies.rectangle(window.innerWidth / 2, -wallThickness / 2, window.innerWidth, wallThickness, { isStatic: true }), // top
    Bodies.rectangle(window.innerWidth / 2, window.innerHeight + wallThickness / 2, window.innerWidth, wallThickness, { isStatic: true }), // bottom
    Bodies.rectangle(-wallThickness / 2, window.innerHeight / 2, wallThickness, window.innerHeight, { isStatic: true }), // left
    Bodies.rectangle(window.innerWidth + wallThickness / 2, window.innerHeight / 2, wallThickness, window.innerHeight, { isStatic: true }) // right
];
Composite.add(world, walls);

// Function to create a Tetris piece
function createTetrisPiece() {
    const blockSize = 30;
    const piece = tetrisPieces[Math.floor(Math.random() * tetrisPieces.length)];
    const blocks = [];
    
    piece.blocks.forEach(([x, y]) => {
        const block = Bodies.rectangle(
            window.innerWidth * Math.random(),
            -50 - y * blockSize,
            blockSize,
            blockSize,
            {
                render: {
                    fillStyle: piece.color,
                    opacity: 0.8
                },
                friction: 0.3,
                restitution: 0.6
            }
        );
        blocks.push(block);
    });
    
    return blocks;
}

// Add pieces periodically
let lastPieceTime = 0;
function addPiecesOverTime(timestamp) {
    if (timestamp - lastPieceTime > 2000) { // Add new piece every 2 seconds
        const newPiece = createTetrisPiece();
        Composite.add(world, newPiece);
        lastPieceTime = timestamp;
    }
    requestAnimationFrame(addPiecesOverTime);
}

// Handle scrolling physics
let lastScrollY = window.scrollY;
document.addEventListener('scroll', () => {
    const deltaY = window.scrollY - lastScrollY;
    const force = deltaY * 0.0005;
    
    Composite.allBodies(world).forEach(body => {
        if (!body.isStatic) {
            Body.setVelocity(body, {
                x: body.velocity.x + (Math.random() - 0.5) * Math.abs(force) * 10,
                y: body.velocity.y + force * 10
            });
        }
    });
    
    lastScrollY = window.scrollY;
});

// Handle window resize
window.addEventListener('resize', () => {
    render.canvas.width = window.innerWidth;
    render.canvas.height = window.innerHeight;
    render.options.width = window.innerWidth;
    render.options.height = window.innerHeight;
    
    // Update walls
    Composite.clear(world, false);
    Composite.add(world, walls);
});

// Start the engine and renderer
Engine.run(engine);
Render.run(render);
requestAnimationFrame(addPiecesOverTime);
</script>

</body>
</html>
